From 3d372c4edfd4dffb7dea71c6b096fb414782b776 Mon Sep 17 00:00:00 2001
From: Johannes Berg <johannes.berg@intel.com>
Date: Fri, 15 Jan 2021 13:05:58 +0200
Subject: [PATCH] iwlwifi: pcie: reschedule in long-running memory reads
Git-commit: 3d372c4edfd4dffb7dea71c6b096fb414782b776
References: git-fixes
Patch-mainline: v5.11-rc6

If we spin for a long time in memory reads that (for some reason in
hardware) take a long time, then we'll eventually get messages such
as

  watchdog: BUG: soft lockup - CPU#2 stuck for 24s! [kworker/2:2:272]

This is because the reading really does take a very long time, and
we don't schedule, so we're hogging the CPU with this task, at least
if CONFIG_PREEMPT is not set, e.g. with CONFIG_PREEMPT_VOLUNTARY=y.

Previously I misinterpreted the situation and thought that this was
only going to happen if we had interrupts disabled, and then fixed
this (which is good anyway, however), but that didn't always help;
looking at it again now I realized that the spin unlock will only
reschedule if CONFIG_PREEMPT is used.

In order to avoid this issue, change the code to cond_resched() if
we've been spinning for too long here.

Signed-off-by: Johannes Berg <johannes.berg@intel.com>
Fixes: 04516706bb99 ("iwlwifi: pcie: limit memory read spin time")
Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
Link: https://lore.kernel.org/r/iwlwifi.20210115130253.217a9d6a6a12.If964cb582ab0aaa94e81c4ff3b279eaafda0fd3f@changeid
Signed-off-by: Oliver Neukum <oneukum@suse.com>
---
 drivers/net/wireless/intel/iwlwifi/pcie/trans.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@ -2133,6 +2133,7 @@ static int iwl_trans_pcie_read_mem(struc
 	u32 *vals = buf;
 
 	while (offs < dwords) {
+		bool resched = false;
 		/* limit the time we spin here under lock to 1/2s */
 		ktime_t timeout = ktime_add_us(ktime_get(), 500 * USEC_PER_MSEC);
 
@@ -2149,10 +2150,14 @@ static int iwl_trans_pcie_read_mem(struc
 				 * do it once in 128 reads
 				 */
 				if (offs % 128 == 0 && ktime_after(ktime_get(),
-								   timeout))
+								   timeout)) {
+					resched = true;
 					break;
+				}
 			}
 			iwl_trans_release_nic_access(trans, &flags);
+			if (resched)
+				cond_resched();
 		} else {
 			return -EBUSY;
 		}
