From c0a5360613cc83131f2ce478e2a81e1e92b270f6 Mon Sep 17 00:00:00 2001
From: Jessica Yu <ppyu@suse.com>
Date: Wed, 16 May 2018 15:05:53 +0200
Subject: [PATCH] x86/cpu_entry_area: Map also trace_idt_table
Patch-mainline: Never, substitutes removal of tracing idt in v4.14-rc1
References: bsc#1089878

From: Petr Mladek <pmladek@suse.com>

Also trace_idt_table need the extra mapping. The table points to
special variants of interrupt handlers that support tracepoints.

Note that it was not needed upstream. These special variants were
removed in v4.14-rc1 as part of a big clean up. See
https://lkml.kernel.org/r/20170828064715.802987421@linutronix.de.

Signed-off-by: Petr Mladek <pmladek@suse.com>
Signed-off-by: Jessica Yu <ppyu@suse.com>
---
 arch/x86/include/asm/cpu_entry_area.h   |    4 +++-
 arch/x86/include/asm/pgtable_32_types.h |    3 ++-
 arch/x86/kernel/traps.c                 |    6 ++++++
 3 files changed, 11 insertions(+), 2 deletions(-)

--- a/arch/x86/include/asm/cpu_entry_area.h
+++ b/arch/x86/include/asm/cpu_entry_area.h
@@ -63,9 +63,11 @@ extern void setup_cpu_entry_areas(void);
 extern void cea_set_pte(void *cea_vaddr, phys_addr_t pa, pgprot_t flags);
 
 #define	CPU_ENTRY_AREA_RO_IDT		CPU_ENTRY_AREA_BASE
-#define CPU_ENTRY_AREA_PER_CPU		(CPU_ENTRY_AREA_RO_IDT + PAGE_SIZE)
+#define CPU_ENTRY_AREA_RO_TRACE_IDT	(CPU_ENTRY_AREA_RO_IDT + PAGE_SIZE)
+#define CPU_ENTRY_AREA_PER_CPU		(CPU_ENTRY_AREA_RO_IDT + 2 * PAGE_SIZE)
 
 #define CPU_ENTRY_AREA_RO_IDT_VADDR	((void *)CPU_ENTRY_AREA_RO_IDT)
+#define CPU_ENTRY_AREA_RO_TRACE_IDT_VADDR ((void *)CPU_ENTRY_AREA_RO_TRACE_IDT)
 
 #ifdef CONFIG_X86_32
 #define CPU_ENTRY_AREA_MAP_SIZE		(CPU_ENTRY_AREA_PER_CPU +		\
--- a/arch/x86/include/asm/pgtable_32_types.h
+++ b/arch/x86/include/asm/pgtable_32_types.h
@@ -43,8 +43,9 @@ extern bool __vmalloc_start_set; /* set
  */
 #define CPU_ENTRY_AREA_PAGES	(NR_CPUS * 40)
 
+/* The extra 2 pages are for idt_table and trace_idt_table. */
 #define CPU_ENTRY_AREA_BASE				\
-	((FIXADDR_START - PAGE_SIZE * (CPU_ENTRY_AREA_PAGES + 1)) & PMD_MASK)
+	((FIXADDR_START - PAGE_SIZE * (CPU_ENTRY_AREA_PAGES + 2)) & PMD_MASK)
 
 #define PKMAP_BASE		\
 	((CPU_ENTRY_AREA_BASE - PAGE_SIZE) & PMD_MASK)
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -1035,6 +1035,12 @@ void __init trap_init(void)
 		    PAGE_KERNEL_RO);
 	idt_descr.address = CPU_ENTRY_AREA_RO_IDT;
 
+#ifdef CONFIG_TRACING
+	cea_set_pte(CPU_ENTRY_AREA_RO_TRACE_IDT_VADDR, __pa_symbol(trace_idt_table),
+		    PAGE_KERNEL_RO);
+	trace_idt_descr.address = CPU_ENTRY_AREA_RO_TRACE_IDT;
+#endif
+
 	/*
 	 * Should be a barrier for any external CPU state:
 	 */
