From: "Borislav Petkov (AMD)" <bp@alien8.de>
Date: Fri, 11 Aug 2023 23:38:24 +0200
Subject: x86/CPU/AMD: Fix the DIV(0) initial fix attempt
Git-commit: f58d6fbcb7c848b7f2469be339bc571f2e9d245b
Patch-mainline: v6.5-rc7
References: bsc#1213927, CVE-2023-20588

Initially, it was thought that doing an innocuous division in the #DE
handler would take care to prevent any leaking of old data from the
divider but by the time the fault is raised, the speculation has already
advanced too far and such data could already have been used by younger
operations.

Therefore, do the innocuous division on every exit to userspace so that
userspace doesn't see any potentially old data from integer divisions in
kernel space.

Do the same before VMRUN too, to protect host data from leaking into the
guest too.

Fixes: 77245f1c3c64 ("x86/CPU/AMD: Do not leak quotient data after a division by 0")
Signed-off-by: Borislav Petkov (AMD) <bp@alien8.de>
Cc: <stable@kernel.org>
Link: https://lore.kernel.org/r/20230811213824.10025-1-bp@alien8.de

Acked-by: nborisov <nik.borisov@suse.com>
---
 arch/x86/entry/common.c   |    2 ++
 arch/x86/kernel/cpu/amd.c |    1 +
 arch/x86/kernel/traps.c   |    7 +------
 arch/x86/kvm/svm.c        |    3 +++
 4 files changed, 7 insertions(+), 6 deletions(-)

--- a/arch/x86/entry/common.c
+++ b/arch/x86/entry/common.c
@@ -31,6 +31,7 @@
 #include <linux/uaccess.h>
 #include <asm/cpufeature.h>
 #include <asm/nospec-branch.h>
+#include <asm/processor.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/syscalls.h>
@@ -211,6 +212,7 @@ __visible inline void prepare_exit_to_us
 	user_enter_irqoff();
 
 	mds_user_clear_cpu_buffers();
+	amd_clear_divider();
 }
 
 #define SYSCALL_EXIT_WORK_FLAGS				\
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -1292,3 +1292,4 @@ void noinstr amd_clear_divider(void)
 	asm volatile(ALTERNATIVE("", "div %2\n\t", X86_BUG_DIV0)
 		     :: "a" (0), "d" (0), "r" (1));
 }
+EXPORT_SYMBOL_GPL(amd_clear_divider);
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -318,12 +318,7 @@ dotraplinkage void do_##name(struct pt_r
 	do_error_trap(regs, error_code, str, trapnr, signr);		\
 }
 
-dotraplinkage void do_divide_error(struct pt_regs *regs, long error_code)
-{
-	do_erro_trap(regs, error_code, "divide error", X86_TRAP_DE, SIGFPE);
-	amd_clear_divider();
-}
-
+DO_ERROR(X86_TRAP_DE,     SIGFPE,  "divide error",              divide_error)
 DO_ERROR(X86_TRAP_OF,     SIGSEGV, "overflow",			overflow)
 DO_ERROR(X86_TRAP_UD,     SIGILL,  "invalid opcode",		invalid_op)
 DO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  "coprocessor segment overrun",coprocessor_segment_overrun)
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -53,6 +53,7 @@
 #include <asm/spec-ctrl.h>
 #include <asm/cpu_device_id.h>
 #include <asm/nospec-branch.h>
+#include <asm/processor.h>
 
 #include <asm/virtext.h>
 #include "trace.h"
@@ -5647,6 +5648,8 @@ static void svm_vcpu_run(struct kvm_vcpu
 	 */
 	x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
 
+	amd_clear_divider();
+
 	local_irq_enable();
 
 	asm volatile (
